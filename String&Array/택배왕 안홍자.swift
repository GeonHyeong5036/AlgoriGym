/*
    택배왕 안홍자.swift
    [Question Link] : 위클리 비타알고 시즌2 강의
    https://edu.goorm.io/lecture/15551/%25ED%2594%2584%25EB%25A6%25AC%25EB%25AF%25B8%25EC%2597%2584-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%259C%2584%25ED%2581%25B4%25EB%25A6%25AC-%25EB%25B9%2584%25ED%2583%2580%25EC%2595%258C%25EA%25B3%25A0-%25EC%258B%259C%25EC%25A6%258C2-%25EC%259E%2585%25EB%25AC%25B8%25ED%258E%25B8

    [문제]
    서울과학기술대학교는 서울특별시 소재 대학교 중 캠퍼스 크기가 5위이다.
    이렇게 큰 캠퍼스를 갖는 학교의 특성 때문인지 학생들 사이에 "택배 서비스"가 유행하고 있다.
    택배 서비스란 일종의 심부름 서비스로 예를 들어 A라는 사람이 i 지역에 있는 물건 등을 j 지역으로 배송해주기를 요청하며 보수를 설정하면 B라는 사람은 해당 심부름을 해주고 보수를 받는 서비스이다.
 
    평소 오토바이를 타고 다니던 안홍자는 택배 서비스에서 매달 최고의 수익을 자랑하는 최고의 배달원이다.
    하지만 최근 홍자는 오토바이를 팔며 고민에 빠졌다. 홍자의 주 수익원이었던 배달 서비스를 이전만큼 할 수 없게 되었기 때문이다.
    너무나도 많은 수익을 올리던 홍자는 씀씀이가 커질 대로 커졌기 때문에 택배 서비스를 아예 그만두는 것은 상상도 못할 일이다.
    그렇기 때문에 홍자는 최고의 효율 즉, 최고의 수익을 낼 방법을 이용하여 배달하고자 한다.
    홍자는 돈을 무지무지 좋아하지만 자신 나름의 규칙에 따라 배달을 해왔기 때문에 오토바이가 없는 지금도 이 규칙을 지키며 배달을 하고자 한다.
     •    홍자는 출발했던 지역에서 공부하고 있었기 때문에 모든 배달을 마친 후 출발 지역으로 돌아와야만 한다.
     •    어떤 지역에서든지 출발할 수 있다.
     •    맨 처음 출발한 지역을 제외하고 한 번 방문했던 지역은 다시 방문할 수 없다.
     •    보수가 없는 경우 홍자는 이동하지 않는다.
     •    모든 지역을 다 방문할 필요는 없다.
     예를 들어 N=3 일 때의 보수가 다음과 같다고 생각해보자.
     0 3 4
     2 0 1
     3 2 0

    이 경우 2번 지역에서 출발하여 1번 지역, 3번 지역 순으로 방문한 후 마지막으로 2번 지역으로 돌아왔을 때 가장 많은 돈을 벌 수 있다.
    홍자를 도와 최고의 수익을 계산해보자!

    [입력]
    첫 번째 줄에는 홍자가 수락한 택배 서비스의 개수 N이 주어진다. (2 <= N <= 10)
    보수는 N * N의 행렬로 나타낼 수 있으며 a_ij는 i 지역에서 j 지역으로 택배 서비스를 제공해주었을 때 받을 수 있는 보수를 뜻한다.
    단 a_ij는 항상  0이고, 한 개 이상의 지역을 방문한 뒤 출발지로 돌아올 수 있는 경우가 존재하는 입력만 주어진다.
 
    [출력]
    홍자가 벌어들일 수 있는 최대 수익을 출력한다.

    [Primary idea] : 완전탐색
    1. 모든 지역을 다 방문할 필요가 없으므로, 두개의 경로가 나온다.
        i)  1 -> 2 -> 3 -> 1
        ii) 1 -> 3 -> 2 -> 1
        단, 두 경로를 회전시켜 모든 경우의 수를 확인 가능하다.
    2. 한 개의 지역을 방문하고 돌아오는 경로부터 개의 지역을 방문하고 돌아오는 경로까지 모든 경로를 다 확인할 필요가 있다
    
    Time Complexity : O(n^2)
    Space Complexity : O(n^2)

    Created by gunhyeong on 2021/01/4.
*/

import Foundation


let N = Int(readLine()!)!
var serviceArea = [[Int]]()

for _ in 0..<N {
    let row = readLine()!.split(separator: " ").map{Int($0)!}
    serviceArea.append(row)
}

var answer = 0
var isUse = [Bool](repeating: false, count: N)
var start = 0

for i in 0..<N {
    start = i
    recursive(i, 0)
}

print(answer)
func recursive(_ s: Int, _ sum: Int) {
    if (s == start) && (sum != 0) {
        answer = max(answer, sum)
        return
    }
    
    for i in 0..<N {
        if isUse[i] { continue }
        if serviceArea[s][i] != 0 {
            isUse[i] = true
            recursive(i, sum + serviceArea[s][i])
            isUse[i] = false
        }
    }
}
